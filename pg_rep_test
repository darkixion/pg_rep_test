#!/bin/bash

# Default values

default_replicas=1 # Default number of replicas
default_starting_port=5530
default_replication_structure='fan'
minimum_max_connections=8 # The minimum number of max connections which will
                          # increase by max_wal_senders.

# Run prerequisite checks
prerequisite_commands="initdb psql pg_basebackup pg_ctl lsof getopts rmdir rm sync tput"

missing_counter=0
for required_command in $prerequisite_commands; do
  if ! hash "$required_command" >/dev/null 2>&1; then
    printf "Required command not found in PATH: %s\n" "$required_command" >&2
    ((missing_counter++))
  fi
done

if ((missing_counter > 0)); then
  printf "%d command(s) are missing in PATH, aborting\n" "$missing_counter" >&2
  exit 1
fi


# Get the version details of the current PostgreSQL installation
read -r pg_version <<<"$(postgres -V | grep -Po '\d+?\.\d+?(\.\d+)?')"

function usage()
{
cat <<OPTIONSDOC
Usage:
  $(basename "$0") [OPTION]

Options:
  -a ARCHIVEDIR          create an archive in the named directory
  -D DATADIRS            comma-separated list of directory names starting with
                         primary (default: primary,standby1,standby2,...)
  -i                     prompt for input of options interactively
  -l LOGFILE             write log messages to a file, but it will not log
                         any pre-check messages
  -L                     enable database logging in every instance
  -p PORTS               comma-separated list of ports to use starting with
                         primary (default: \
$default_starting_port,\
$(( default_starting_port + 1 )),\
$(( default_starting_port + 2 )),...)
  -r REPLICAS            number of replicas to create (default: 1)
  -R                     use replication slots
  -s fan|tree|chain      replication structure (default: fan)
                         fan = all standbys connect directly to primary
                         tree = one standby connects directly to primary, the
                                remaining ones connect to that standby
                         chain = no more than one standby connects to any node
  -S                     configures all standbys to be synchronous
  -T                     don't generate management tool script file to manage
                         the new instances
  -?                     show this help then exit
OPTIONSDOC
}

while getopts "a:D:il:Lp:r:Rs:ST?" option
do
  case $option in
    a)
      archive_dir=$OPTARG
      ;;
    D)
      datadirs=$OPTARG
      ;;
    i)
      interactive=true
      ;;
    l)
      log_file=$OPTARG
      ;;
    L)
      enable_logs=true
      ;;
    p)
      ports=$OPTARG
      ;;
    r)
      replicas=$OPTARG
      ;;
    R)
      replication_slots=true
      ;;
    s)
      replication_structure=$OPTARG
      ;;
    S)
      synchronous=true
      ;;
    T)
      tool=false
      ;;
    ?)
      usage
      exit 1
      ;;
  esac
done

printf "Detected version of PostgreSQL: %s\n\n" "$pg_version"

# Configure colour variables if outputting to the terminal.
if [ -t 1 ]
then
  blue='\e[1;94m'
  green='\e[1;32m'
  red='\e[1;31m'
  yellow='\e[1;93m'
  plain=$(tput sgr0)
fi

error_text="$red"'Error'"$plain"

# Ensure we create the tool when there's an error so it can be cleaned
# up easily.
function catch_broken_instances()
{
  echo -e "\n[$red ERROR!$plain ] An error occured while trying to create or start instances."

  if [[ -z $tool ]]
  then
    create_tool
  fi
}

# Cast a version number into a zero-padded string for comparison.
function version()
{
  echo "$@" | awk -F. '{ printf("%d%03d%03d\n", $1,$2,$3); }'
}

# Generate a list of unused ports to run instances on.
function generate_ports()
{
  local start_time
  start_time=$(date +%s)
  local delay_warning=false
  local IFS=","

  auto_port_list=()

  for (( port=default_starting_port, port_count=0; port_count <= replicas; port++ ))
  do
    if [[ $(( $(date +%s) - start_time )) -gt 4 ]] && [ "$delay_warning" == false ]
    then
      echo "Notice: Currently determining available ports.  This is taking"\
           "longer than usual possibly due to many other instances already"\
           "running."
      delay_warning=true
    fi

    # Check if the port is currently being used.
    if lsof -i:$port > /dev/null
    then
      continue # port in use, so try next one
    else
      auto_port_list=(${auto_port_list[@]} $port)
      port_count=$((port_count + 1))
    fi
  done
}

# Generate a list of unused directory names in which to generate instances.
function generate_dirs()
{
  # If the primary directory already exists, suffix a number and try again.
  while [[ $(ls -A "primary"${subset:+'_'$subset} 2> /dev/null) ]]
  do
    ((subset++))
  done
  auto_dir_list[0]="primary"${subset:+'_'$subset}

  unset subset

  # Generate a standby directory for each replica.
  for (( replica=1; replica <= replicas; replica++ ))
  do
    # If the standby directory already exists, suffix a number and try again.
    while [[ $(ls -A "standby$replica"${subset:+'_'$subset} 2> /dev/null) ]]
    do
      ((subset++))
    done
    auto_dir_list[$replica]="standby$replica"${subset:+'_'$subset}

    unset subset
  done
}

# Output a summary of the current settings.
function settings_summary()
{
  # Note that a 3rd value passed to output_report here has a coalescing effect
  # where if the 2nd one is empty, the 3rd is accepted as the 2nd parameter.
  echo "==== SETTINGS SUMMARY ===="
  output_report "Replicas" "$replicas"
  output_report "Ports" "${port_list[*]}"
  output_report "Directories" "${dir_list[*]}"
  output_report "Archive dir" "$archive_dir" "[None]"
  output_report "Replication structure" "$replication_structure"
  output_report "Synchronous" "$synchronous"
  if [ "$(version "$pg_version")" -ge "$(version "9.4.0")" ]
  then
    output_report "Replication slots" "$replication_slots"
  fi
  output_report "Database logging" $enable_logs
  output_report "Log file" "$log_file"
  echo -e "==========================\n"

  # If no parameters were provided, these are considered the defaults, so
  # allow the user to decide whether they want to change anything.
  if [ $# -eq 0 ] && $interactive
  then
    echo "Do you want to use these values or input your own?"
    select yn in "Use these values" "Customise"; do
      case $yn in
        "Use these values" )
          break
          ;;
        "Customise" )
          request_params;
          settings_summary;
          break
          ;;
      esac
    done
  fi
}

# Request user-input to modify default parameters.
function request_params()
{
  # Input number of replicas
  while true
  do
    local input_replicas=0

    echo # newline
    read -rp "How many replicas do you want in addition to the primary? [default:${replicas:-$default_replicas}] " input_replicas

    check_replica_count_numeric "$input_replicas"

    if [[ $? -eq 0 ]]
    then
      # If there is a new number of replicas, regenerate the default ports and
      # directories.
      if [[ $input_replicas -ne 0 ]] &&
         [[ $input_replicas -ne ${replicas:-$default_replicas} ]]
      then
        unset port_list dir_list

        replicas=${input_replicas:-${replicas:-$default_replicas}}

        generate_ports
        generate_dirs

        port_list=(${port_list[*]:-${auto_port_list[@]}})
        dir_list=(${dir_list[*]:-${auto_dir_list[@]}})
      fi
      break
    fi
  done


  # Input port list
  while true
  do
    local input_ports=()

    echo # newline
    read -rp "Input comma-separated list of ports: [default:${port_list[*]}] " input_ports

    input_ports=(${input_ports[*]:-${port_list[@]}})

    check_port_count "${input_ports[*]}"

    if [[ $? -eq 0 ]]
    then
      check_ports_numeric "${input_ports[*]}"
    else
      continue
    fi

    if [[ $? -eq 0 ]]
    then
      port_list=(${input_ports[*]})
      break;
    fi
  done

  # Input instance directory list
  while true
  do
    local input_dirs=()

    echo # newline
    read -rp "Input comma-separated list of directories: [default:${dir_list[*]}] " input_dirs

    input_dirs=(${input_dirs[*]:-${dir_list[@]}})

    check_directory_count "${input_dirs[*]}"

    if [[ $? -eq 0 ]]
    then
      check_directory_usage "${input_dirs[*]}"
    else
      continue
    fi

    if [[ $? -eq 0 ]]
    then
      dir_list=(${input_dirs[*]})
      break;
    fi
  done

  # Input archive directory
  while true
  do
    local input_archive_dir=''

    echo # newline
    read -rp "Input archive directory (leave blank to disable archiving): [default:${input_archive_dir:-${archive_dir:-(disabled)}}] " input_archive_dir

    check_archive_dir_usage "$input_archive_dir"

    if [[ $? -eq 0 ]]
    then
      archive_dir=$input_archive_dir
      break;
    fi

    break;
  done

  # Input replication structure
  echo # newline
  echo "Select a replication structure: [current value:${input_replication_structure:-${replication_structure:-$default_replication_structure}}]"

  select input_replication_structure in "fan" "tree" "chain"; do
    case $input_replication_structure in
      "fan" | "tree" | "chain" )
        replication_structure=$input_replication_structure
        break
        ;;
    esac
  done

  # Input replication durability

  if $synchronous
  then
    replication_durability="synchronous"
  else
    replication_durability="asynchronous"
  fi

  echo # newline
  echo "Select replication durability: [current value:$replication_durability]"
  select input_replication_durability in "asynchronous" "synchronous"; do
    case $input_replication_durability in
      "asynchronous" )
        synchronous=false
        break
        ;;
      "synchronous" )
        synchronous=true
        break
        ;;
    esac
  done

  # Use replication slots

  if [ "$(version "$pg_version")" -ge "$(version "9.4.0")" ]
  then

    if $replication_slots
    then
      replication_slots_ENABLED="yes"
    else
      replication_slots_ENABLED="no"
    fi

    echo #newline
    echo "Do you want to use replication slots? [current value:$replication_slots_ENABLED]"
    select input_replication_slots in "yes" "no"; do
      case $input_replication_slots in
        "yes" )
          replication_slots=true
          break
          ;;
        "no" )
          replication_slots=false
          break
          ;;
      esac
    done
  fi

  # Enable/disable database logging
  if $enable_logs
  then
    database_logging_enabled="yes"
  else
    database_logging_enabled="no"
  fi

  echo # newline
  echo "Do you want to enable logging on each database instance? [current value:$database_logging_enabled]"
  select input_database_logging in "yes" "no"; do
    case $input_database_logging in
      "yes" )
        enable_logs=true
        break
        ;;
      "no" )
        enable_logs=false
        break
        ;;
    esac
  done

  # Input script log file
  while true
  do
    local input_log_file=''

    echo # newline
    read -rp "Input script log file name (leave blank to pipe to /dev/null): [default:${input_log_file:-/dev/null}] " input_log_file

    log_file=${input_log_file:-/dev/null}

    break;
  done
}

function build_ascii_report()
{
  local current_level=$1
  local IFS=""

  # Indent everything according to replication structure.
  if [[ $current_level -eq 1 ]]
  then
    ascii_report="\n[Primary (${port_list[0]})]\n"
  else
    case $replication_structure in
      fan)
        indent=1
        ;;
      tree)
        if [[ $current_standby -eq 1 ]]
        then
          indent=1
        else
          indent=2
        fi
        ;;
      chain)
        indent=$(( current_standby % 10 ))
        if [[ $indent -eq 0 ]]
        then
          ascii_report=$ascii_report"----------------------------------------------------------------------------/\n"
        fi
        ;;
    esac

    spacer=""
    for (( I=1; I <= indent; I++ ))
    do
      spacer=$spacer'    '
      if [[ $I -gt 1 ]]
      then
        spacer=$spacer'    '
      fi
    done
    ascii_report=$ascii_report$spacer"|\n"
    ascii_report=$ascii_report$spacer"---[Standby $current_standby (${port_list[$current_standby]})]\n"

  fi
}

# Output text to a log file, prepending the date and time.
# Parameter 1 (optional): Contains 'STDOUT' if the entry should be displayed.
function write_log()
{
  local output=$1
  local nonewline=$2

  if [[ "$nonewline" == 'nonewline' ]]
  then
    option='-n'
  else
    option=''
  fi

  while IFS= read -r line
  do
    if [[ "$output" == STDOUT ]]
    then
        echo $option "$line"
    fi

    echo "$(date +'%Y-%m-%d %H:%M:%S') $line" >> "$log_file"
  done
}

# Writes a coloured title followed by its value
# Parameter 1: Title to be output in colour
# Parameter 2: Value
function output_report()
{
  local title=$1
  local value=$2

  echo -ne "$blue  $title: $plain"
  echo "$value"
}

# Based on the status provided, reports SUCCESS or FAILED
# Parameter 1: The exit code of the process being reported
function report_status()
{
  local status=$1

  if [[ $status -eq 0 ]] && [[ -n $status ]]
  then
    echo -ne "$green" # green
    echo -e " SUCCESS!" | write_log STDOUT nonewline
  else
    echo -ne "$red" # red
    echo -e " FAILED!" | write_log STDOUT nonewline
  fi
  echo "$plain" # reset colours

  return "$status"
}

function start_instance()
{
  local instance_dir=$1
  local instance_number=$2
  local retry_count=$3
  local check_only=${4:-false}
  local status=0

  if [ "$check_only" == false ]
  then
    # Start the instance now that it's been configured.
    if [[ $instance_number -eq 1 ]]
    then
      echo "Starting primary..." | write_log STDOUT nonewline
      echo "pg_ctl -w -D $dir start" | write_log
      pg_ctl -w -D "$dir" -s start >> "$log_file"
      sleep 1
    else
      echo -e "Starting standby $current_standby..." | write_log STDOUT nonewline
      echo "pg_ctl -w -D $dir start" | write_log
      pg_ctl -w -D "$dir" -s start >> "$log_file"
    fi
  fi

  # Ensure everything is flushed to disk before checking whether the service
  # is up and running
  sync

  # Test that the primary or standby has started successfully.
  echo "pg_ctl -D $dir status" | write_log
  pg_ctl -D "$dir" status &>> "$log_file"

  status=$?
  echo "status is $status" | write_log

  report_status $status

  # If the instance fails to start, retry
  if [[ $retry_count -gt 0 ]]
  then
    case $status in
      0)
        # do nothing
        ;;
      *)
        echo -e "Error: Failed to start instance in '$instance_dir'.  Rechecking..." | write_log STDOUT 
        sleep 0.5

        echo "pg_ctl -D $dir status" | write_log
        pg_ctl -D "$dir" status &>> "$log_file"
        status=$?
        echo "status is $status" | write_log
        report_status $status

        if [ "$status" == 0 ]
        then
          return 0
        fi

        echo "Error: Instance doesn't appear to be available '$instance_dir'.  Retrying..." | write_log STDOUT 
        start_instance "$instance_dir" "$instance_number" $(( retry_count - 1 ))
        ;;
      esac
  elif [[ $status -ne 0 ]]
  then
    echo "Error: Attempts to start '$instance_dir' have failed." | write_log STDOUT 
    exit 1
  fi
}


## Validation check functions

function check_version_support()
{
  # Check that we're using a supported version
  if [ "$(version "$pg_version")" -lt "$(version "9.1.0")" ]
  then
    echo -e "$error_text: Only PostgreSQL 9.1 and above is supported.  You are using"\
         "PostgreSQL $pg_version."
    exit 1
  fi
}

function check_replication_slot_support()
{
  # If replication slots have been requested, ensure we're using 9.4 or above
  if [ "$(version "$pg_version")" -lt "$(version "9.4.0")" ] && [ "$replication_slots" == true ]
  then
    echo -e "$error_text: Replication slots (-R) are only supported in PostgreSQL 9.4"\
         "and above.  You are using PostgreSQL $pg_version."
    exit 1
  fi
}

function check_replica_count_numeric()
{
  local input_replicas=$1
  local fatal=${2:-false}
  # Check that the replicas value is numeric if provided.
  if [[ -n $input_replicas ]] && ! [[ $input_replicas =~ ^[0-9]+$ ]]
  then
    echo -e "$error_text: The number of replicas must be a numeric value."
    if $fatal;then exit 1;else return 1;fi
  fi
}

function check_replication_structure()
{
  # Validate replication structure value.
  if [[ -n $replication_structure ]]
  then
    case $replication_structure in
      "fan" | "tree" | "chain" )
        ;;
      * )
        echo -e "$error_text: Invalid replica structure specified."
        exit 1
    esac
  fi
}

function check_cascading_replication_support()
{
  # Throw an error if any attempt to use a cascading replication feature prior to
  # PostgreSQL 9.2.
  if ( [ "$(version "$pg_version")" -lt "$(version "9.2.0")" ] ) && [[ $replication_structure != 'fan' ]]
  then
    echo -e "$error_text:  The replication structure '$replication_structure' is not supported prior to"\
         "PostgreSQL 9.2 as it requires cascading replication."
    exit 1
  fi
}

function check_port_count()
{
  local input_port_list=($1)
  local fatal=${2:-false}

  # Ensure that the number of ports equals the number of replicas plus the
  # primary.

  if [[ -n $replicas ]] && [[ ${#input_port_list[@]} -ne 0 ]] && [[ ${#input_port_list[*]} -ne $(( replicas + 1 )) ]]
  then
    echo -e "$error_text: The number of ports provided does not match the number of replicas + primary."
    if $fatal
    then
      exit 1
    else
      return 1
    fi
  fi
}

function check_ports_numeric()
{

  local input_ports=($1)
  local fatal=${2:-false}

  for port in "${input_ports[@]}"
  do
    # Check that the port value is numeric if provided.
    if [[ -n $port ]] && ! [[ $port =~ ^[0-9]+$ ]]
    then
      echo -e "$error_text:  Invalid port '$port'. Port values must be numeric."
      if $fatal
      then
        exit 1
      else
        return 1
      fi
    fi
  done
}

function check_port_usage()
{
  # Check that the ports listed aren't already in use.
  for port in "${port_list[@]}"
  do
    if lsof -i:"$port" > /dev/null
    then
      echo -e "$error_text:  Port $port already in use.  Specify a list of unused ports with the -p option, or omit this parameter to auto-select ports."
      exit 1
    fi
  done
}

function check_directory_count()
{
  local input_dir_list=($1)
  local fatal=${2:-false}

  # Check that the number of directories is equal to the number of standbys plus
  # the primary.
  if [[ -n $replicas ]] && [[ "${#input_dir_list[@]}" -ne 0 ]] && [[ ${#input_dir_list[@]} -ne $(( replicas + 1 )) ]]
  then
    echo -e "$error_text: The number of directories provided does not match a primary + the number of replicas."
    if $fatal
    then
      exit 1
    else
      return 1
    fi
  fi
}

function check_directory_usage()
{
  # Check each directory to see if it's empty if it already exists.
  for dir in "${dir_list[@]}"
  do
    # Check for duplicate directory names in supplied list
    if [[ $(echo "${dir_list[*]}" | grep -owc "$dir") -gt 1 ]]
    then
      echo -e "$error_text: The directory '$dir' is specified more than once in the provided list."
      if $fatal
      then
        exit 1
      else
        return 1
      fi
    fi

    if [[ -d $dir ]]
    then
      if [[ $(ls -A "$dir") ]]
      then
        echo -e "$error_text: The directory '$dir' already exists and is not empty."
        if $fatal
        then
          exit 1
        else
          return 1
        fi
      fi
    fi
  done
}

function check_archive_dir_usage()
{
  local input_archive_dir=$1
  local fatal=${2:-false}

  if [[ -d $input_archive_dir ]]
  then
    if [[ $(ls -A "$input_archive_dir") ]]
    then
      echo -e "$error_text: The archive directory '$input_archive_dir' already exists and is not empty."
      if $fatal
      then
        exit 1
      else
        return 1
      fi
    fi
  fi
}



########## CREATE TOOL CODE BEGIN  ##########

function create_tool()
{

file_header=$(cat <<-TOOL_CONFIG
	#!/bin/bash

	# instance data associated with this maintenance script
	datadirs=(${dir_list[*]})
	ports=(${port_list[*]})
	archive_dir=${archive_dir:-''}
TOOL_CONFIG
)

file_body=$(cat <<-'TOOL_FILE'
	function usage()
	{
	cat << OPTIONSDOC

	Usage:
	  $0 [OPTION] [ACTION]

	Options:
	  -m MODE                shutdown mode (smart, fast or immediate); must be
	                         used with the 'stop' action
	  -l LOGFILE             write log messages to a file
	  -?                     show this help then exit

	action can be one of:
	  status                 list all instances, their ports, data directories and
	                         whether they are running or not
	  start                  start all instances
	  stop                   stops all instances, which can be used with the -m 
	                         option
	  restart                restart all instances
	  destroy                stops (if started) and deletes all instances; also
	                         deletes this maintenance script
	OPTIONSDOC
	}

	# Configure colour variables if outputting to the terminal
	if [ -t 1 ]
	then
	  blue='\e[1;94m'
	  green='\e[1;32m'
	  red='\e[1;31m'
	  plain=$(tput sgr0)
	fi

	while getopts “m:l:?” option
	do
	  case $option in
	    m)
	      mode=$OPTARG
	      ;;
	    l)
	      log_file=$OPTARG
	      ;;
	    ?)
	      usage
	      exit 1
	      ;;
	  esac
	done

	action=${!#}
	mode=${mode:-'smart'}

	# Set default for log output
	if [[ -z $log_file ]]
	then
	  log_file='/dev/null'
	fi

	# Output text to a log file, prepending the date and time.
	# Parameter 1 (optional): Contains 'STDOUT' if the entry should be displayed.
	function write_log()
	{
	  local output=$1
	  local nonewline=$2

	  if [[ "$nonewline" == 'nonewline' ]]
	  then
	    option='-n'
	  else
	    option=''
	  fi

	  while IFS= read -r line
	  do
	    if [[ "$output" == STDOUT ]]
	    then
	      echo $option $line
	    fi

	    echo $(date +\%Y-\%m-\%d\ \%H:\%M:\%S) $line >> $log_file
	  done
	}

	# Return the number of bytes an XLog position represents.
	function xlog_in_bytes()
	{
	  local xlogid="${1%%/*}"
	  local offset="${1##*/}"
	  echo $((0xFFFFFF * 0x$xlogid + 0x$offset))
	}

	# Return the XLog location of an instance given a port and whether it's a
	# standby.
	function xlog_location()
	{
	  local port=$1
	  local standby=$2

	  case ${standby:-$(in_recovery $port)} in
	    true)
	      xlog_function='pg_last_xlog_replay_location'
	      ;;
	    false)
	      xlog_function='pg_current_xlog_location'
	      ;;
	    *)
	      echo "N/A"
	      return 0
	      ;;
	  esac

	  echo 'psql -p '"$port"' -Atc "'"SELECT $xlog_function();"'" postgres 2>> /dev/null' | write_log
	  echo $(psql -p $port -Atc "SELECT $xlog_function();" postgres 2>> $log_file)
	}

	# Given the port of a standby, find the port of the primary that the standby
	# is subscribing to.
	function get_primary_port()
	{
	  local standby_port=$1
	  local primary_port_query="\
	    WITH q AS (\
	      SELECT "*" FROM regexp_split_to_table( pg_read_file('recovery.conf'), E'\\\\n') AS x\
	      )\
	      SELECT regexp_replace(x, '.*port=([0-9]*).*', E'\\\\1')\
	      FROM q\
	      WHERE x ~ '^[[:space:]]*primary_conninfo';"
	  echo 'psql -p $standby_port -Atc $primary_port_query postgres 2>> /dev/null' | write_log
	  echo $(psql -p $standby_port -Atc $primary_port_query postgres 2>> /dev/null)
	}

	# Determine whether the specified port is in recovery mode.
	function in_recovery()
	{
	  local target_port=$1
	  echo "psql -p $target_port -Atc 'SELECT pg_is_in_recovery();' postgres 2>> /dev/null" | write_log
	  local recovery=$(psql -p $target_port -Atc 'SELECT pg_is_in_recovery();' postgres 2>> $log_file)
	  local status=$?

	  case "$recovery" in
	    "t")
	      echo true
	      ;;
	    "f")
	      echo false
	      ;;
	    *)
	      # return nothing (i.e. starting up)
	      ;;
	  esac
	}

	# Based on the status provided, reports SUCCESS or FAILED
	# Parameter 1: The exit code of the process being reported
	function report_status()
	{
	  local status=$1

	  if [[ $status -eq 0 ]] && [[ -n $status ]]
	  then
	    echo -ne $green # green
	    echo -e ' SUCCESS!' | write_log STDOUT nonewline
	  else
	    echo -ne $red # red
	    echo -e ' FAILED!' | write_log STDOUT nonewline
	  fi
	  echo $plain # reset colours

	  return $status
	}

	function status()
	{
	  local status=''
	  local status_colour=''
	  local primary_port=''
	  local in_recovery=1

	  # Output summary table title.
	  local table_title=$(printf " %-${instance_name_length}s | %-${instance_port_length}s | Primary Port | Status      | XLog location | Replication lag (bytes)" "Instance" "Port")
	  echo "$table_title"
	  printf "%$(( ${#table_title} ))s\n" |tr " " "-"

	  for (( I=0; I < ${#datadirs[@]}; I++ ))
	  do
	    if [[ -e ${datadirs[$I]}/postgresql.conf ]]
	    then
	      echo "pg_ctl status -D ${datadirs[$I]}" | write_log
	      pg_ctl status -D ${datadirs[$I]} >> $log_file

	      case $? in
	        0)
	          status_colour=$green

	          case $(in_recovery ${ports[$I]}) in
	            true)
	              status='IN RECOVERY'
	              primary_port=$(get_primary_port ${ports[$I]})

	              echo 'psql -h localhost -p '"$primary_port"' -c "SELECT 1;" postgres' | write_log
	              psql -h localhost -p $primary_port -c 'SELECT 1;' postgres &>> $log_file

	              if [[ $? -eq 0 ]]
	              then
	                primary_xlog_location=$(xlog_location $primary_port)
	              fi

	              xlog_location=$(xlog_location ${ports[$I]} true)
	              if [[ "$primary_log_location" == 'N/A' ]]
	              then
	                xlog_lag='N/A'
	              else
	                xlog_lag=$(( $(xlog_in_bytes $primary_xlog_location) - $(xlog_in_bytes $xlog_location) ))
	              fi
	              ;;
	            false)
	              status='ONLINE'

	              primary_port=''
	              primary_xlog_location=$(xlog_location ${ports[$I]} false)

	              xlog_location=$primary_xlog_location
	              xlog_lag=''
	              ;;
	            *)
	              status='STARTING UP'
	              primary_port="N/A"
	              xlog_location="N/A"
	              xlog_lag=''
	          esac
	          ;;
	        3)
	          local status='OFFLINE'
	          local status_colour=$red
	          xlog_location='N/A'
	          primary_port='N/A'
	          ;;
	      esac

	      printf " %-${instance_name_length}s | %-${instance_port_length}s | %-12s | $status_colour%-11s$plain | %-13s | %'d\n" "${datadirs[$I]}" "${ports[$I]}" "$primary_port" "$status" "$xlog_location" "$xlog_lag"
	      unset status status_colour xlog_lag primary_xlog_location
	    else
	      printf " %-${instance_name_length}s | %-${instance_port_length}s | %-12s | $red%-11s$plain | %-13s | %-4s\n" "${datadirs[$I]}" "N/A" "N/A" "MISSING" "N/A" "N/A"
	    fi
	  done
	}

	function destroy()
	{
	  for instance in ${datadirs[@]}
	  do
	    pg_ctl -D $instance status >> $log_file
	    if [[ $? -eq 0 ]]
	    then
	      # Stop the instance before we delete it.
	      echo -e "Stopping instance in '$instance'..." | write_log STDOUT nonewline
	      echo 'pg_ctl stop -D '$instance' -W -m immediate' | write_log
	      pg_ctl stop -D $instance -W -m immediate &>> $log_file
	      sync

	      # Get the status to ensure it has stopped.
	      echo "pg_ctl status -D $instance" | write_log
	      pg_ctl status -D $instance >> $log_file
	      if [[ $? -eq 3 ]]
	      then
	        report_status '0'
	      fi
	    else
	      echo "Instance in '$instance' already stopped." | write_log STDOUT
	    fi

	    # Delete the current instance.
	    echo -e "Deleting instance in '$instance'..." | write_log STDOUT nonewline
	    echo 'rm -r '$instance'/*' | write_log
	    rm -r $instance/* &>> $log_file
	    echo 'rmdir '$instance | write_log
	    rmdir $instance &>> $log_file
	    report_status $?
	  done

	  # Delete archive directory recursively, if it exists.
	  if [[ $archive_dir != '' ]]
	  then
	    echo -e "Deleting archive in '$archive_dir'..." | write_log STDOUT nonewline
	    echo 'rm -rf '$archive_dir'/*' | write_log
	    rm -rf $archive_dir/* &>> $log_file
	    echo 'rmdir '$archive_dir | write_log
	    rmdir $archive_dir &>> $log_file
	    report_status $?
	  fi

	  # Delete the tool script itself
	  echo -e "Deleting this tool script..." | write_log STDOUT nonewline
	  echo 'rm '$0 | write_log
	  rm $0 &>> $log_file
	  report_status $?
	}

	function start()
	{
	  for instance in ${datadirs[@]}
	  do
	    if [[ -e $instance/postgresql.conf ]]
	    then
	      pg_ctl -D $instance status >> $log_file
	      if [[ $? -ne '0' ]]
	      then
	        echo -e "Starting instance in '$instance'..." | write_log STDOUT nonewline
	        echo 'pg_ctl start -D '$instance | write_log
	        pg_ctl start -D $instance &>> $log_file
	        sync
	        echo "pg_ctl status -D $instance" | write_log
	        pg_ctl status -D $instance >> $log_file
	        report_status $?
	      else
	        echo "Instance in '$instance' already started." | write_log STDOUT
	      fi
	    else
	      echo "Skipping instance '$instance' as no config file was found." | write_log STDOUT
	    fi
	  done
	}

	function stop()
	{
	  for instance in ${datadirs[@]}
	  do
            if [[ -e $instance/postgresql.conf ]]
            then
	      pg_ctl -D $instance status >> $log_file
	      if [[ $? -eq 0 ]]
	      then
	        echo -e "Stopping instance in '$instance'..." | write_log STDOUT nonewline
	        echo 'pg_ctl stop -D '$instance' -m '$mode | write_log
	        pg_ctl stop -D $instance -m $mode &>> $log_file
	        report_status $?
	      else
	        echo "Instance in '$instance' already stopped." | write_log STDOUT
	      fi
	    else
	      echo "Skipping instance '$instance' as no config file was found." | write_log STDOUT
	    fi
	  done
	}

	function restart()
	{
	  for instance in ${datadirs[@]}
	  do
	    if [[ -e $instance/postgresql.conf ]]
	    then
	      echo -e "Restarting instance in '$instance'..." | write_log STDOUT nonewline
	      echo 'pg_ctl restart -D '$instance | write_log
	      pg_ctl restart -D $instance &>> $log_file
	      sync
	      echo "pg_ctl status -D $instance" | write_log
	      pg_ctl status -D $instance >> $log_file
	      report_status $?
	    else
	      echo "Skipping instance '$instance' as no config file was found." | write_log STDOUT
	    fi
	  done
	}

	function max_array_element_length()
	{
	  local input_array=($1)
	  local max_element_length=0

	  for ELEMENT in ${input_array[@]}
	  do
	    if [[ $max_element_length -lt ${#ELEMENT} ]]
	    then
	      max_element_length=${#ELEMENT}
	    fi
	  done

	  echo $max_element_length
	}

	IFS="|"
	instance_name_length=$(max_array_element_length "${datadirs[*]}|Instance")
	instance_port_length=$(max_array_element_length "${ports[*]}|Ports")

	case $action in
	  destroy)
	    destroy
	    ;;
	  start)
	    start
	    ;;
	  stop)
	    stop
	    ;;
	  restart)
	    restart
	    ;;
	  status)
	    status
	    ;;
	  *)
	    echo 'Error: Invalid action '$action' specified.'
	    usage
	    exit 1
	esac
TOOL_FILE
)

  local IFS=""
  while [[ $(ls -A "tool${subset:+'_'$subset}.pg_rep_test" 2> /dev/null) ]]
  do
    ((subset++))
  done
  tool_filename="tool${subset:+_$subset}.pg_rep_test"
  unset subset

  echo "$file_header" > $tool_filename
  echo "$file_body" >> $tool_filename
  chmod u+x $tool_filename

  echo -e "\nThe maintenance tool script for these instances is '$tool_filename'." | write_log STDOUT
  echo -e "Run $yellow./$tool_filename -?$plain for help with using it.\n"
}

########## CREATE TOOL CODE END  ##########



IFS=","
port_list=($ports)
dir_list=($datadirs)
IFS=" "

check_version_support

# From PostgreSQL 9.3, initdb accepts the -N parameter which tells it not to
# wait for files to be written to disk. We can do this as we're creating
# disposable databases anyway.
if [ "$(version "$pg_version")" -ge "$(version "9.3.0")" ]
then
  initdb_nosync='-N'
  initdb_checksums='-k'
fi

#### Validate parameters ####

# Set default number of replicas to 1.
if [[ -z $replicas ]]
then
  replicas=1
fi

check_replica_count_numeric $replicas true

# Set default for log output
if [[ -z $log_file ]]
then
  log_file='/dev/null'
fi

check_replication_structure
check_replication_slot_support
check_cascading_replication_support

# If a list of ports hasn't been specified, generate the list of ports.
if [[ -z $ports ]]
then
  generate_ports
else
  check_port_usage "${port_list[*]}" true
fi
check_directory_count "${dir_list[*]}" true

# If a list of directories was not explicitly specified, generate the default
# directory names.
if [[ -z $datadirs ]]
then
  generate_dirs
else
  check_directory_usage "${dir_list[*]}" true
fi

check_archive_dir_usage "$archive_dir" true

# Set default values where necessary
dir_list=(${dir_list[*]:-${auto_dir_list[@]}})
enable_logs=${enable_logs:-false}
interactive=${interactive:-false}
port_list=(${port_list[*]:-${auto_port_list[@]}})
replication_structure=${replication_structure:-$default_replication_structure}
synchronous=${synchronous:-false}
replication_slots=${replication_slots:-false}

check_port_count "${port_list[*]}" true
check_ports_numeric "${port_list[*]}" true

#### Set up instances ####

echo "Command issued: $0 $*" > $log_file

settings_summary

instances=$(( replicas + 1 ))

# Create directories.
echo "mkdir -p -m 0700 ${dir_list[*]}" | write_log
mkdir -p -m 0700 "${dir_list[@]}" &>> /dev/null

if [[ $? -ne 0 ]]
then
  echo "Error: Unable to create directory '$dir'."
  exit 1
fi

# If the directory already existed, the permissions may not be correct
# so apply what's necessary for a database cluster.
chmod 0700 "${dir_list[@]}" &>> /dev/null

# Create archive directory
if [[ -n $archive_dir ]]
then
  mkdir -p -m 0700 "$archive_dir"

  # Check that the archive directory can be written to.  We can get away with
  # trying to create it first because if the directory already existed but
  # we don't have permissions to write to it, mkdir will act as if it succeeded.
  if ! [[ -w $archive_dir ]]
  then
    echo "Error: The archive directory '$archive_dir' doesn't have write permissions."
    exit 1
  fi
fi

# Initialise the primary and create standbys.

trap catch_broken_instances 0

for (( instance=1; instance <= instances; instance++ ))
do
  current_standby=$(( instance - 1 ))
  max_wal_senders=0
  dir=${dir_list[$current_standby]}

  # Create the primary and create standby from base backup of primary.
  if [[ $instance -eq 1 ]]
  then
    echo -e "Creating primary in '$dir'..." | write_log STDOUT nonewline
    echo "initdb $initdb_nosync $initdb_checksums -D $dir -E 'UTF8'" | write_log
    initdb $initdb_nosync $initdb_checksums -D "$dir" -E 'UTF8' &>> $log_file
    report_status $?

    if [[ $? -ne 0 ]]
    then
      echo "Error: Unable to create primary."
      exit 1
    fi

    # Add an include to pull in the custom configuration contained in
    # custom.conf.
    echo "include 'custom.conf'" 2>> $log_file 1>> "$dir/postgresql.conf"

    {
      echo -e "# This file contains custom configuration changes made by pg_rep_test\n"

      # Reduce the resource requirements to enable a large number of standbys.
      echo -e "shared_buffers = 8MB       # This is set low to allow a large number of standbys to be set up\n"

      if $enable_logs
      then
        echo -e "logging_collector = on\n"
        echo -e "log_line_prefix = '%m - %u - %d'"
      fi

      # Define list of standbys.  We want to set this up in the primary prior to
      # base backup so that any promoted standby can use the same list.
      if $synchronous
      then
        sync_standby_list='standby1'
        for (( sync_standby=2; sync_standby <= replicas; sync_standby++ ))
        do
          sync_standby_list=$sync_standby_list",standby${sync_standby}"
        done
          echo -e "synchronous_standby_names = '${sync_standby_list}'\n"
      fi

      if [[ -n $archive_dir ]]
      then
        echo -e "archive_mode = on\n"
        echo -e "archive_command = 'cp \"%p\" \"$(readlink -f "${archive_dir}")/%f\"'\n"
      fi
    } 2>> $log_file 1>> "$dir/custom.conf"

    # Create a copy of the custom config before we modify it further
    # because the remaining settings should only apply to the primary.
    # Every standby will use this copy.
    echo "cp $dir/custom.conf{,.template}" | write_log
    cp "$dir/custom.conf"{,.template} 2>> $log_file
  elif [[ $current_standby -eq 1 ]]
  then
    echo -e "Creating standby $current_standby from primary in '${dir}'..." | write_log STDOUT nonewline
    echo "pg_basebackup -X fetch -D $dir -h localhost -p ${port_list[0]} -U rep_user" | write_log
    pg_basebackup -X fetch -D "$dir" -h localhost -p "${port_list[0]}" -U rep_user &>> $log_file

    report_status $?

    if [[ $? -ne 0 ]]
    then
      continue
    fi

    # Restore the copy of the config for the standby as we want a
    # copy without any primary-specific modifications.
    mv "$dir"/custom.conf{.template,}
    if [[ -n $archive_dir ]]
    then
      echo -e "restore_command = 'cp \"$(readlink -f "$archive_dir")/%f\" \"%p\"'" 2>> $log_file 1>> "$dir/recovery.conf"
    fi

    # Now that we've got one base backup, we can just copy it for every remaining standby.
    if [[ $replicas -gt 1 ]]
    then
      for (( standby=2; standby<=replicas; standby++ ))
      do
        echo -e "Creating copy of standby 1 for standby $standby in '${dir_list[$standby]}'..." | write_log STDOUT nonewline
        echo "cp -r $dir/. ${dir_list[$standby]}" | write_log
        cp -r "$dir/." "${dir_list[$standby]}" 2>> $log_file

        report_status $?

        if [[ $? -ne 0 ]]
        then
          continue
        fi
      done
    fi
  fi

  build_ascii_report $instance

  case "$replication_structure" in
    fan)
      case "$instance" in
        1) # primary
         # Only the primary will be sending WAL.
         max_wal_senders=$(( replicas + 3 ))
         # the primary doesn't subscribe to any port or slot but will create
         # a slot for all standbys in a fan configuration.
          unset subscribe_port
          unset subscribe_slot
          create_slots=(${dir_list[*]:1})
          ;;
        *) # all standbys
          # all standbys subscribe directly to the primary in a fan
          # configuration on both port and slot, but none create slots.
          subscribe_port=${port_list[0]}
          subscribe_slot=${dir_list[$instance - 1]}
          unset create_slots
          ;;
      esac
      ;;
    tree)
      case "$instance" in
        1) # primary
          # Only the primary and 1st standby will be sending WAL.
          max_wal_senders=3
          unset subscribe_port
          unset subscribe_slot
          create_slots=${dir_list[1]}
          ;;
        2) # 1st standby
          max_wal_senders=$(( replicas + 2 ))
          subscribe_port=${port_list[0]}
          subscribe_slot=${dir_list[$instance - 1]}
          create_slots=(${dir_list[@]:2})
          ;;
        *) # remaining standby
          subscribe_port=${port_list[1]}
          subscribe_slot=${dir_list[$instance - 1]}
          unset create_slots
          ;;
      esac
      ;;
    chain)
       # The primary and every standby except the last will be sending WAL.
       max_wal_senders=3

      case "$instance" in
        1) #primary
          unset subscribe_port
          unset subscribe_slot
          create_slots=${dir_list[1]}
          ;;
        *)
          subscribe_port=${port_list[$instance - 2]}
          subscribe_slot=${dir_list[$instance - 1]}
          create_slots=${dir_list[$instance]}
          ;;
        "$instances") # last standby
          unset max_wal_senders
          unset create_slots
          ;;
      esac
      ;;
  esac

  # Configure max_connections to accommodate max_wal_senders.  Note that this
  # value must be identical between primary and any standby, but the standby
  # can have a higher value for max_wal_senders than the primary if we're using
  # a tree replication structure, so set it to accommodate all replicas which
  # should cover all eventualities.
  if [[ $instance -eq 1 ]]
  then
    if [[ "$replication_structure" == "chain" ]]
    then
      max_connections=$(( 3 + minimum_max_connections ))
    else
      max_connections=$(( replicas + 2 + minimum_max_connections ))
    fi
  fi

  {
    echo -e "max_connections = ${max_connections}        # This needs to accommodate max_wal_senders connections in addition to\n" \
          "                          # regular connections.\n"
    echo -e "wal_level = 'hot_standby'  # This needs to be set to 'hot_standby' so that standbys can accept connections.\n"
    echo -e "port = ${port_list[$current_standby]}\n"
  } 2>> $log_file 1>> "$dir/custom.conf"

  if [ "$(version "$pg_version")" -ge "$(version "9.5.0")" ]
  then
    echo -e "cluster_name = '${dir_list[$current_standby]}'\n" 2>> $log_file 1>> "$dir/custom.conf"
  fi

  # Only set up streaming replication configuration for instances that will
  # use it.
  if [[ $max_wal_senders -gt 0 ]]
  then
    echo -e "max_wal_senders = ${max_wal_senders}        # This is set to number of subscribing standbys + 1.  This then allows use\n" \
            "                          # of tools like pg_basebackup that also uses streaming replication.\n" 2>> $log_file 1>> "$dir/custom.conf"

    # If replication slots are to be used, set the number of replication slots
    # to match that of WAL senders.  Otherwise we need to guess how many WAL
    # files to keep behind.
    if $replication_slots
    then
      echo -e "max_replication_slots = ${max_wal_senders}  # This allows the standbys to tell the primary what WAL\n" \
	      "                          # location they're up to." 2>> $log_file 1>> "$dir/custom.conf"
    else
      echo "wal_keep_segments = 6" 2>> $log_file 1>> "$dir/custom.conf"
    fi

    if [[ $instance -eq 1 ]]
    then
      # Add authentication entries to replicate to a slave.
      {
        echo "local   replication     rep_user                           trust"
        echo "host    replication     rep_user   127.0.0.1/32            trust"
        echo "host    replication     rep_user   ::1/128                 trust"
      } 2>> $log_file 1>> "$dir/pg_hba.conf"
    fi
  fi

  # Set all standbys to be hot standbys.
  if [[ $instance -ne 1 ]]
  then
    echo "hot_standby = on           # Needed to allow connection to this standby" 2>> $log_file 1>> "$dir/custom.conf"
    {
      echo "standby_mode = 'on'"
      echo "recovery_target_timeline = 'latest'"
      echo "primary_conninfo = 'host=127.0.0.1 user=rep_user port=${subscribe_port} application_name=standby${current_standby}'"
    } 2>> $log_file 1>> "$dir/recovery.conf"

    if $replication_slots
    then
      echo "primary_slot_name = '${subscribe_slot}_physical_slot'" 2>> $log_file 1>> "$dir/recovery.conf"
    fi
  fi

  start_instance "$dir" "$instance" 1

  if $replication_slots
  then
    unset create_replication_slots_command
    if [[ -n $create_slots ]]
    then
      for create_slot in ${create_slots[*]}
      do
        create_replication_slots_command=$create_replication_slots_command"SELECT pg_create_physical_replication_slot('${create_slot}_physical_slot');"
      done
    fi
  fi

  # Create user to be used for replication.  We have to disable synchronous
  # replication for the CREATE USER command as we don't have any available
  # standbys at this point.
  if [[ $instance -eq 1 ]]
  then
    echo "psql -p ${port_list[0]} -h localhost -c 'SET SESSION synchronous_commit TO 'off';CREATE USER rep_user REPLICATION;$create_replication_slots_command;' -d postgres" | write_log
    psql -p "${port_list[0]}" -h localhost -c "SET SESSION synchronous_commit TO 'off';CREATE USER rep_user REPLICATION;$create_replication_slots_command" -d postgres &>> $log_file

    if [[ $? -ne 0 ]]
    then
      echo "Error: Failed to connect to primary."
      exit 1
    fi
  elif $replication_slots
  then
    echo "psql -p ${port_list[$current_standby]} -h localhost -c 'SET SESSION synchronous_commit TO 'off';$create_replication_slots_command;' -d postgres" | write_log
    psql -p "${port_list[$current_standby]}" -h localhost -c "SET SESSION synchronous_commit TO 'off';$create_replication_slots_command" -d postgres &>> $log_file

    if [[ $? -ne 0 ]]
    then
      echo "Error: Failed to connect to standby $current_standby."
      exit 1
    fi
  fi
done

# Now that all instances have been created and started, we can cancel the trap.
trap - 0

# Output the final ASCII representation of the replication structure.
IFS=""
echo -e "$ascii_report"
IFS=" "

if [[ -z $tool ]]
then
  create_tool
fi

exit 0
