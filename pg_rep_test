#!/bin/bash

# Get the version details of the current PostgreSQL installation
read PG_MAJOR_VERSION PG_MINOR_VERSION <<<$(postgres -V | grep -Po '\d+?\.\d+?' | cut -d '.' --output-delimiter=' ' -f 1,2)

usage()
{
cat << OPTIONSDOC
Usage:
  $0 [OPTION]

Options:
  -a ARCHIVEDIR          create an archive in the named directory
  -d DATADIRS                comma-separated list of directory names starting with
                         primary (default: primary,standby1,standby2,...)
  -l LOGFILE             write log messages to a file, but it will not log
                         any pre-check messages
  -L                     enable database logging in every instance
  -p PORTS               comma-separated list of ports to use starting with
                         primary (default: 5530,5531,5532,...)
  -r REPLICAS            number of replicas to create (default: 1)
  -s fan|tree|chain      replication structure (default: fan)
                         fan = all standbys connect directly to primary
                         tree = one standby connects directly to primary, the
                                remaining ones connect to that standby
                         chain = no more than one standby connects to any node
  -S                     configures all standbys to be synchronous
  -T                     don't generate management tool script file to manage the
                         new instances
  -?                     show this help then exit
OPTIONSDOC
}

# Configure colour variables if outputting to the terminal
if [ -t 1 ]
then
  BLUE='\e[1;94m'
  GREEN='\e[1;32m'
  RED='\e[1;31m'
  YELLOW='\e[1;93m'
  PLAIN=$(tput sgr0)
fi

while getopts “a:d:l:Lp:r:s:ST?” OPTION
do
  case $OPTION in
    a)
      ARCHIVE_DIR=$OPTARG
      ;;
    d)
      DATADIRS=$OPTARG
      ;;
    l)
      LOG_FILE=$OPTARG
      ;;
    L)
      ENABLE_LOGS=true
      ;;
    p)
      PORTS=$OPTARG
      ;;
    r)
      REPLICAS=$OPTARG
      ;;
    s)
      REPSTRUCT=$OPTARG
      ;;
    S)
      SYNCHRONOUS=true
      ;;
    T)
      TOOL=false
      ;;
    ?)
      usage
      exit 1
      ;;
  esac
done

generate_ports()
{
  AUTO_PORT_LIST=()
  for (( PORT=5530, PORT_COUNT=0; PORT_COUNT <= $REPLICAS; PORT++ ))
  do
    if lsof -i:$PORT > /dev/null
    then
      continue; # port in use, so try next one
    else
      AUTO_PORT_LIST+=($PORT)
      PORT_COUNT=$[PORT_COUNT + 1];
    fi
  done
}

generate_dirs()
{
  while [[ $(ls -A "primary"${SUBSET:+'_'$SUBSET} 2> /dev/null) ]]
  do
    ((SUBSET++))
  done
  AUTO_DIR_LIST[0]="primary"${SUBSET:+'_'$SUBSET}
  unset SUBSET

  for (( REPLICA=1; REPLICA <= $REPLICAS; REPLICA++ ))
  do
    while [[ $(ls -A "standby$REPLICA"${SUBSET:+'_'$SUBSET} 2> /dev/null) ]]
    do
      ((SUBSET++))
    done
    AUTO_DIR_LIST[$REPLICA]="standby$REPLICA"${SUBSET:+'_'$SUBSET}
    unset SUBSET
  done
}

build_ascii_report()
{
  CURRENT_LEVEL=$INSTANCE

  # Indent everything according to replication structure.
  if [[ $CURRENT_LEVEL -eq 1 ]]
  then
    ASCII_REPORT="\n[Primary (${PORT_LIST[0]})]\n"
  else
    case $REPSTRUCT in
      fan)
        INDENT=1
        ;;
      tree)
        if [[ $CURRENT_STANDBY -eq 1 ]]
        then
          INDENT=1
        else
          INDENT=2
        fi
        ;;
      chain)
        INDENT=$CURRENT_STANDBY
        ;;
    esac

    SPACER=""
    for (( I=1; I <= $INDENT; I++ ))
    do
      SPACER=$SPACER"    "
      if [[ $I -gt 1 ]]
      then
        SPACER=$SPACER"    "
      fi
    done
    ASCII_REPORT=$ASCII_REPORT$SPACER"|\n"
    ASCII_REPORT=$ASCII_REPORT$SPACER"---[Standby $CURRENT_STANDBY (${PORT_LIST[$CURRENT_STANDBY]})]\n"

  fi
}

# Output text to a log file, prepending the date and time.
# Parameter 1 (optional): Contains 'STDOUT' if the entry should be displayed.
write_log()
{
  OUTPUT=$1
  NONEWLINE=$2

  if [[ $NONEWLINE == 'NONEWLINE' ]]
  then
    OPTION='-n'
  else
    OPTION=''
  fi

  while IFS= read -r LINE
  do
    if [[ $OUTPUT == STDOUT ]]
    then
        echo $OPTION $LINE
    fi

    echo "$(date +\%Y-\%m-\%d\ \%H:\%M:\%S) $LINE" >> $LOG_FILE
  done
}

# Writes a coloured title followed by its value
# Parameter 1: Title to be output in colour
# Parameter 2: Value
output_report()
{
  TITLE=$1
  VALUE=$2

  echo -ne "$BLUE  $TITLE: $PLAIN"
  echo $VALUE
}

# Based on the status provided, reports SUCCESS or FAILED
# Parameter 1: The exit code of the process being reported
report_status()
{
  STATUS=$1

  if [[ $STATUS -eq '0' ]] && [[ -n $STATUS ]]
  then
    echo -ne $GREEN # green
    echo -e " SUCCESS!" | write_log STDOUT NONEWLINE
  else
    echo -ne $RED # red
    echo -e " FAILED!" | write_log STDOUT NONEWLINE
  fi
  echo $PLAIN # reset colours

  return $STATUS
}




########## CREATE TOOL CODE BEGIN  ##########

create_tool()
{
FILE_HEADER=$(cat <<TOOL_CONFIG
#!/bin/bash

# instance data associated with this maintenance script
DATADIRS=(${DIR_LIST[*]})
PORTS=(${PORT_LIST[*]})
TOOL_CONFIG
)

FILE_BODY=$(cat <<'TOOL_FILE'
usage()
{
cat << OPTIONSDOC
Usage:
  $0 [OPTION] [ACTION]

Options:
  -D DATADIRS            comma-separated list of directories of instances
                         to affect
  -m MODE                shutdown mode (smart, fast or immediate); must be
                         used with the 'stop' action
  -l LOGFILE             write log messages to a file
  -?                     show this help then exit

ACTION can be one of:
  status                 lists of all managed instances, their ports, data
                         directories and whether they are running or not
  start                  start all or specified instances
  stop                   stops all or specified instances, which can be used
                         with the -m option
  restart                restart all or specified instances
  destroy                stops (if started) and deletes all or specified
                         instances; also deletes this maintenance script
OPTIONSDOC
}

# Configure colour variables if outputting to the terminal
if [ -t 1 ]
then
  BLUE='\e[1;94m'
  GREEN='\e[1;32m'
  RED='\e[1;31m'
  PLAIN=$(tput sgr0)
fi

IFS=','

while getopts “D:m:l:?” OPTION
do
  case $OPTION in
    D)
      DATADIRS=($OPTARG)
      ;;
    m)
      MODE=$OPTARG
      ;;
    l)
      LOG_FILE=$OPTARG
      ;;
    ?)
      usage
      exit 1
      ;;
  esac
done

ACTION=${!#}
MODE=${MODE:-'smart'}

# Set default for log output
if [[ -z $LOG_FILE ]]
then
  LOG_FILE='/dev/null'
fi

# Output text to a log file, prepending the date and time.
# Parameter 1 (optional): Contains 'STDOUT' if the entry should be displayed.
write_log()
{
  OUTPUT=$1
  NONEWLINE=$2

  if [[ $NONEWLINE == 'NONEWLINE' ]]
  then
    OPTION='-n'
  else
    OPTION=''
  fi

  while IFS= read -r LINE
  do
    if [[ $OUTPUT == STDOUT ]]
    then
        echo $OPTION $LINE
    fi

    echo $(date +\%Y-\%m-\%d\ \%H:\%M:\%S) $LINE >> $LOG_FILE
  done
}

# Based on the status provided, reports SUCCESS or FAILED
# Parameter 1: The exit code of the process being reported
report_status()
{
  STATUS=$1

  if [[ $STATUS -eq '0' ]] && [[ -n $STATUS ]]
  then
    echo -ne $GREEN # green
    echo -e ' SUCCESS!' | write_log STDOUT NONEWLINE
  else
    echo -ne $RED # red
    echo -e ' FAILED!' | write_log STDOUT NONEWLINE
  fi
  echo $PLAIN # reset colours

  return $STATUS
}

status()
{
  for (( I=0; I < ${#DATADIRS[@]}; I++ ))
  do
    echo -n "Instance '${DATADIRS[$I]}' on port [${PORTS[$I]}]: "
    echo "pg_ctl status -D ${DATADIRS[$I]}" | write_log
    pg_ctl status -D ${DATADIRS[$I]} >> $LOG_FILE
    case $? in
      0)
        echo -e $GREEN'RUNNING'$PLAIN
        ;;
      3)
        echo -e $RED'NOT RUNNING'$PLAIN
        ;;
    esac
  done
}

destroy()
{
  for INSTANCE in ${DATADIRS[@]}
  do
    pg_ctl -D $INSTANCE status >> $LOG_FILE
    if [[ $? -eq '0' ]]
    then
      echo -e "Stopping instance in '$INSTANCE'..." | write_log STDOUT NONEWLINE
      echo 'pg_ctl stop -D '$INSTANCE' -m immediate' | write_log
      pg_ctl stop -D $INSTANCE -m immediate &>> $LOG_FILE
      sync
      echo "pg_ctl status -D $INSTANCE" | write_log
      pg_ctl status -D $INSTANCE >> $LOG_FILE
      if [[ $? -eq '3' ]]
      then
        report_status '0'
      fi
    else
      echo "Instance in '$INSTANCE' already stopped." | write_log STDOUT
    fi

    echo -e "Deleting instance in '$INSTANCE'..." | write_log STDOUT NONEWLINE
    echo 'rm -r '$INSTANCE'/*' | write_log
    rm -r $INSTANCE/* &>> $LOG_FILE
    echo 'rmdir '$INSTANCE | write_log
    rmdir $INSTANCE &>> $LOG_FILE
    report_status $?
  done
  rm $0
}

start()
{
  for INSTANCE in ${DATADIRS[@]}
  do
    pg_ctl -D $INSTANCE status >> $LOG_FILE
    if [[ $? -ne '0' ]]
    then
      echo -e "Starting instance in '$INSTANCE'..." | write_log STDOUT NONEWLINE
      echo 'pg_ctl start -D '$INSTANCE | write_log
      pg_ctl start -D $INSTANCE &>> $LOG_FILE
      sync
      echo "pg_ctl status -D $INSTANCE" | write_log
      pg_ctl status -D $INSTANCE >> $LOG_FILE
      report_status $?
    else
      echo "Instance in '$INSTANCE' already started." | write_log STDOUT
    fi
  done
}

stop()
{
  for INSTANCE in ${DATADIRS[@]}
  do
    pg_ctl -D $INSTANCE status >> $LOG_FILE
    if [[ $? -eq '0' ]]
    then
      echo -e "Stopping instance in '$INSTANCE'..." | write_log STDOUT NONEWLINE
      echo 'pg_ctl stop -D '$INSTANCE' -m '$MODE | write_log
      pg_ctl stop -D $INSTANCE -m $MODE &>> $LOG_FILE
      report_status $?
    else
      echo "Instance in '$INSTANCE' already stopped." | write_log STDOUT
    fi
  done
}

restart()
{
  for INSTANCE in ${DATADIRS[@]}
  do
      echo -e "Restarting instance in '$INSTANCE'..." | write_log STDOUT NONEWLINE
      echo 'pg_ctl restart -D '$INSTANCE | write_log
      pg_ctl restart -D $INSTANCE &>> $LOG_FILE
      sync
      echo "pg_ctl status -D $INSTANCE" | write_log
      pg_ctl status -D $INSTANCE >> $LOG_FILE
      report_status $?
  done
}

case $ACTION in
  destroy)
    destroy
    ;;
  start)
    start
    ;;
  stop)
    stop
    ;;
  restart)
    restart
    ;;
  status)
    status
    ;;
  * )
    echo 'Error: Invalid action '$ACTION' specified.'
    usage
    exit 1
esac
TOOL_FILE
)

while [[ $(ls -A "tool"${SUBSET:+'_'$SUBSET}".pg_rep_test" 2> /dev/null) ]]
do
  ((SUBSET++))
done
TOOL_FILENAME="tool"${SUBSET:+'_'$SUBSET}".pg_rep_test"
unset SUBSET

echo $FILE_HEADER > $TOOL_FILENAME
echo $FILE_BODY >> $TOOL_FILENAME
chmod u+x $TOOL_FILENAME

echo -e "The maintenance tool script for these instances is '$TOOL_FILENAME'." | write_log STDOUT
echo -e "Run $YELLOW./$TOOL_FILENAME -?$PLAIN for help with using it." | write_log STDOUT
}

########## CREATE TOOL CODE END  ##########




IFS=","
PORT_LIST=($PORTS)
DIR_LIST=($DATADIRS)

# Check that we're using a supported version
if ( [[ PG_MAJOR_VERSION -eq 9 ]] && [[ PG_MINOR_VERSION -eq 0 ]] ) || [[ PG_MAJOR_VERSION -lt 9 ]]
then
  echo "Error: Only PostgreSQL 9.1 and above is supported.  You are using"\
       "PostgreSQL $PG_MAJOR_VERSION.$PG_MINOR_VERSION"
  exit 1
fi

# From PostgreSQL 9.3, initdb accepts the -N parameter which tells it not to
# wait for files to be written to disk. We can do this as we're creating
# disposable databases anyway.
if ( [[ PG_MAJOR_VERSION -eq 9 ]] && [[ PG_MINOR_VERSION -ge 3 ]] ) || [[ PG_MAJOR_VERSION -gt 9 ]]
then
  INITDB_NOSYNC='-N'
fi

#### Validate parameters ####

# Set default number of replicas to 1.
if [[ -z $REPLICAS ]]
then
  REPLICAS=1
fi

# Check that the replicas value is numeric if provided.
if [[ -n $REPLICAS ]] && ! [[ $REPLICAS =~ ^[0-9]+$ ]]
then
  echo 'Error: The number of replicas must be a numeric value.'
  exit 1
fi

INSTANCES=`expr $REPLICAS + 1`

# Set default for log output
if [[ -z $LOG_FILE ]]
then
  LOG_FILE='/dev/null'
fi

# Validate replication structure value.
if [[ -n $REPSTRUCT ]]
then
  case $REPSTRUCT in
    fan|tree|chain)
      ;;
    * )
      echo 'Error: Invalid replica structure specified.'
      exit 1
  esac
fi

# Throw an error if any attempt to use a cascading replication feature prior to
# PostgreSQL 9.2.
if ( [[ PG_MAJOR_VERSION -eq 9 ]] && [[ PG_MINOR_VERSION -lt 2 ]] ) && [[ $REPSTRUCT != 'fan' ]]
then
  echo "Error: The replication structure '$REPSTRUCT' is not supported prior to"\
       "PostgreSQL 9.2 as it requires cascading replication."
  exit 1
fi

# Ensure that if a list of ports has been provided, the number of ports equals
# the number of replicas plus the primary.
if [[ -n $REPLICAS ]] && [[ -n $PORTS ]] && [[ ${#PORT_LIST[@]} -ne `expr $REPLICAS + 1` ]]
then
  echo 'Error: The number of ports provided does not match the number of replicas + primary.'
  exit 1
fi

# If a list of ports hasn't been specified, generate the list of ports.
if [[ -z $PORTS ]]
then
  generate_ports
else
  # Check that the ports listed aren't already in use.
  for PORT in ${PORT_LIST[@]}
  do
    if lsof -i:$PORT > /dev/null
    then
      echo "Error: Port $PORT already in use.  Specify a list of unused ports with the -p option, or omit this parameter to auto-select ports."
      exit 1
    fi
  done
fi


# Check that the number of directories is equal to the number of standbys plus
# the primary.
if [[ -n $REPLICAS ]] && [[ -n $DATADIRS ]] && [[ ${#DIR_LIST[@]} -ne `expr $REPLICAS + 1` ]]
then
  echo 'Error: The number of directories provided does not match a primary + the number of replicas.'
  exit 1
fi

# If a list of directories was not explicitly specified, generate the default
# directory names.
if [[ -z $DATADIRS ]]
then
  generate_dirs
else
  # Check each directory to see if it's empty if it already exists.
  for DIR in ${DIR_LIST[@]}
  do
    # Check for duplicate directory names in supplied list
    if [[ `echo ${DIR_LIST[*]} | grep -o $DIR | wc -l` -gt 1 ]]
    then
       echo "Error: The directory '$DIR' is specified more than once in the provided list."
       exit 1
    fi

    if [[ -d $DIR ]]
    then
      if [[ $(ls -A $DIR) ]]
      then
        echo "Error: The directory '$DIR' already exists and is not empty."
        exit 1
      fi
    fi
  done
fi

# Set default values where necessary

DIR_LIST=(${DIR_LIST[*]:-${AUTO_DIR_LIST[@]}})
ENABLE_LOGS=${ENABLE_LOGS:-false}
PORT_LIST=(${PORT_LIST[*]:-${AUTO_PORT_LIST[@]}})
REPSTRUCT=${REPSTRUCT:-'fan'}
SYNCHRONOUS=${SYNCHRONOUS:-false}

#### Set up instances ####

IFS=" "
echo "Command issued: $0 $*" > $LOG_FILE
IFS=","

# Note that a 3rd value passed to output_report here has a coalescing effect
# where if the 2nd one is empty, the 3rd is accepted as the 2nd parameter.
echo "==== SETTINGS SUMMARY ===="
output_report "Replicas" $REPLICAS
output_report "Ports" "${PORT_LIST[*]}"
output_report "Directories" "${DIR_LIST[*]}"
output_report "Archive dir" $ARCHIVE_DIR "[None]"
output_report "Replication structure" $REPSTRUCT
output_report "Synchronous" $SYNCHRONOUS
output_report "Database logging" $ENABLE_LOGS
output_report "Log flie" $LOG_FILE
echo -e "==========================\n"

# Create directories.
mkdir -p -m 0700 ${DIR_LIST[@]} &>> /dev/null

if [[ $? -ne 0 ]]
then
  echo "Error: Unable to create directory '$DIR'."
  exit 1
fi

# If the directory already existed, the permissions may not be correct
# so apply what's necessary for a database cluster.
chmod 0700 ${DIR_LIST[@]} &>> /dev/null

# Create archive directory
if [[ -n $ARCHIVE_DIR ]]
then
  mkdir -p -m 0700 $ARCHIVE_DIR

  # Check that the archive directory can be written to.  We can get away with
  # trying to create it first because if the directory already existed but
  # we don't have permissions to write to it, mkdir will act as if it succeeded.
  if ! [[ -w $ARCHIVE_DIR ]]
  then
    echo "Error: The archive directory '$ARCHIVE_DIR' doesn't have write permissions."
    exit 1
  fi
fi

# Initialise the primary and create standbys.

for (( INSTANCE=1; INSTANCE <= $INSTANCES; INSTANCE++ ))
do
  CURRENT_STANDBY=`expr $INSTANCE - 1`
  MAX_WAL_SENDERS=0
  DIR=${DIR_LIST[$CURRENT_STANDBY]}

  # Create the primary and create standby from base backup of primary.
  if [[ $INSTANCE -eq 1 ]]
  then
    echo -e "Creating primary in '$DIR'..." | write_log STDOUT NONEWLINE
    echo "initdb $INITDB_NOSYNC -D $DIR -E 'UTF8'" | write_log
    initdb $INITDB_NOSYNC -D $DIR -E 'UTF8' &>> $LOG_FILE
    report_status $?

    if [[ $? -ne 0 ]]
    then
      echo "Error: Unable to create primary."
      exit 1
    fi

    # Add an include to pull in the custom configuration contained in
    # custom.conf.
    echo "include 'custom.conf'" 2>> $LOG_FILE 1>> $DIR/postgresql.conf
    echo -e "# This file contains custom configuration changes made by pg_rep_test\n" 2>> $LOG_FILE 1>>$DIR/custom.conf

    # Reduce the resource requirements to enable a large number of standbys.
    echo -e "shared_buffers = 8MB       # This is set low to allow a large number of standbys to be set up\n" 2>> $LOG_FILE 1>> $DIR/custom.conf

    if $ENABLE_LOGS
    then
      echo -e "logging_collector = on\n" 2>> $LOG_FILE 1>> $DIR/custom.conf
    fi

    # Define list of standbys.  We want to set this up in the primary prior to
    # base backup so that any promoted standby can use the same list.
    if $SYNCHRONOUS
    then
      SYNC_STANDBY_LIST='standby1'
      for (( SYNC_STANDBY=2; SYNC_STANDBY <= $REPLICAS; SYNC_STANDBY++ ))
      do
        SYNC_STANDBY_LIST=$SYNC_STANDBY_LIST",standby$SYNC_STANDBY"
      done
        echo -e "synchronous_standby_names = '$SYNC_STANDBY_LIST'\n" 2>> $LOG_FILE 1>> $DIR/custom.conf
    fi

    if [[ -n $ARCHIVE_DIR ]]
    then
      echo -e "archive_mode = on\n" 2>> $LOG_FILE 1>> $DIR/custom.conf
      echo -e "$(echo archive_command = \'cp \"%p\" \"`readlink -f $ARCHIVE_DIR`/%f\"\')\n" 2>> $LOG_FILE 1>> $DIR/custom.conf
    fi

    # Create a copy of the custom config before we modify it further
    # because the remaining settings should only apply to the primary.
    # Every standby will use this copy.
    echo "cp $DIR/custom.conf{,.template}" | write_log
    cp $DIR/custom.conf{,.template} 2>> $LOG_FILE
  elif [[ $CURRENT_STANDBY -eq 1 ]]
  then
    echo -e "Creating standby $CURRENT_STANDBY from primary in '$DIR'..." | write_log STDOUT NONEWLINE
    echo "pg_basebackup -D $DIR -h 127.0.0.1 -p ${PORT_LIST[0]}" | write_log
    pg_basebackup -D $DIR -h 127.0.0.1 -p ${PORT_LIST[0]} &>> $LOG_FILE

    report_status $?

    if [[ $? -ne 0 ]]
    then
      continue
    fi

    # Restore the copy of the config for the standby as we want a
    # copy without any primary-specific modifications.
    mv $DIR/custom.conf{.template,}
    if [[ -n $ARCHIVE_DIR ]]
    then
      echo -e "$(echo restore_command = \'cp \"`readlink -f $ARCHIVE_DIR`/%f\" \"%p\"\')" 2>> $LOG_FILE 1>> $DIR/recovery.conf
    fi

    # Now that we've got one base backup, we can just copy it for every remaining standby.
    if [[ $REPLICAS -gt 1 ]]
    then
      for (( STANDBY=2; STANDBY<=$REPLICAS; STANDBY++ ))
      do
        echo -e "Creating copy of standby 1 for standby $STANDBY in '${DIR_LIST[$STANDBY]}'..." | write_log STDOUT NONEWLINE
        echo "cp -r $DIR/. ${DIR_LIST[$STANDBY]}" | write_log
        cp -r "$DIR/." "${DIR_LIST[$STANDBY]}" 2>> $LOG_FILE

        report_status $?

        if [[ $? -ne 0 ]]
        then
          continue
        fi
      done
    fi
  fi

  build_ascii_report

  # Set max_wal_senders appropriately so that it has a sufficient amount to
  # serve the standbys that will subscribe to it.
  case $REPSTRUCT in
    fan)
      # Only the primary will be sending WAL.
      if [[ $INSTANCE -eq 1 ]]
      then
        MAX_WAL_SENDERS=`expr $REPLICAS + 3`
      fi
      ;;
    tree)
      # Only the primary and 1st standby will be sending WAL.
      case $INSTANCE in
        1)
          MAX_WAL_SENDERS=3
          ;;
        2)
          MAX_WAL_SENDERS=`expr $REPLICAS + 2`
          ;;
      esac
      ;;
    chain)
      # The primary and every standby except the last will be sending WAL.
      if [[ $INSTANCE -lt `expr $REPLICAS + 1` ]]
      then
         MAX_WAL_SENDERS=3
      fi
      ;;
  esac

  # Configure to replicate.
  echo -e "wal_level = 'hot_standby'  # This needs to be set to 'hot_standby' so that standbys can be connected to\n" 2>> $LOG_FILE 1>> $DIR/custom.conf
  echo -e "port = ${PORT_LIST[$CURRENT_STANDBY]}\n" 2>> $LOG_FILE 1>> $DIR/custom.conf

  # Only set up streaming replication configuration for instances that will
  # use it.
  if [[ $MAX_WAL_SENDERS > 0 ]]
  then
    echo -e "max_wal_senders = $MAX_WAL_SENDERS        # This is set to number of subscribing standbys + 1.  This then allows use\n" \
         "                          # of tools like pg_basebackup that also uses streaming replication.\n"  2>> $LOG_FILE 1>> $DIR/custom.conf
    echo "wal_keep_segments = 32" 2>> $LOG_FILE 1>> $DIR/custom.conf

    if [[ $INSTANCE -eq 1 ]]
    then
      # Add authentication entries to replicate to a slave.
      echo "local   replication     all                                trust" 2>> $LOG_FILE 1>> $DIR/pg_hba.conf
      echo "host    replication     all        127.0.0.1/32            trust" 2>> $LOG_FILE 1>> $DIR/pg_hba.conf
      echo "host    replication     all        ::1/128                 trust" 2>> $LOG_FILE 1>> $DIR/pg_hba.conf
    fi
  fi

  # Set all standbys to be hot standbys.
  if [[ $INSTANCE -ne 1 ]]
  then
    echo "hot_standby = on           # Needed to allow connection to this standby" 2>> $LOG_FILE 1>> $DIR/custom.conf
    echo "standby_mode = 'on'" 2>> $LOG_FILE 1>> $DIR/recovery.conf
    echo "recovery_target_timeline = 'latest'" 2>> $LOG_FILE 1>> $DIR/recovery.conf

    case $REPSTRUCT in
      fan)
        # All standbys subscribe to the primary directly.
        SUBSCRIBE_PORT=${PORT_LIST[0]}
        ;;
      tree)
        # Only the 1st standby subscribes directly to the primary. The rest
        # subscribe to the 1st standby.
        case $INSTANCE in
        2)
          SUBSCRIBE_PORT=${PORT_LIST[0]}
          ;;
        *)
          SUBSCRIBE_PORT=${PORT_LIST[1]}
          ;;
        esac
        ;;
      chain)
        # Every standby subscribes to the previous standby, or primary in the
        # case of the 1st standby.
        SUBSCRIBE_PORT=${PORT_LIST[`expr $INSTANCE - 2`]}
        ;;
    esac
    echo "primary_conninfo = 'host=127.0.0.1 port=$SUBSCRIBE_PORT application_name=standby$CURRENT_STANDBY'" 2>> $LOG_FILE 1>> $DIR/recovery.conf
  fi

  # Start the instance now that it's been configured.
  if [[ $INSTANCE -eq 1 ]]
  then
    echo "Starting primary..." | write_log STDOUT NONEWLINE
    echo "pg_ctl -D $DIR start" | write_log
    pg_ctl -D $DIR -s start >> $LOG_FILE
  else
    echo -e "Starting standby $CURRENT_STANDBY..." | write_log STDOUT NONEWLINE
    echo "pg_ctl -D $DIR start" | write_log
    pg_ctl -D $DIR -s start >> $LOG_FILE
  fi

  # Ensure everything is flushed to disk before checking whether the service
  # is up and running
  sync

  # Test that the primary or standby has started successfully.
  pg_ctl -D $DIR status >> $LOG_FILE
  report_status $?

  # If the primary fails, there's no point in continuing.
  if [[ $? -ne 0 ]] && [[ $INSTANCE -eq 1 ]]
  then
    echo "Error: Failed to start primary."
    exit 1;
  fi
done

# Output the final ASCII representation of the replication structure.
echo -e $ASCII_REPORT

if [[ -z $TOOL ]]
then
  create_tool
fi

exit 1
