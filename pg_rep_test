#!/bin/bash

# Get the version details of the current PostgreSQL installation
read PG_MAJOR_VERSION PG_MINOR_VERSION <<<$(postgres -V | grep -Po '\d+?\.\d+?' | cut -d '.' --output-delimiter=' ' -f 1,2)

usage()
{
cat << OPTIONSDOC
Usage:
  $0 [OPTION]

Options:
  -a ARCHIVEDIR          create an archive in the named directory
  -d DIRS                comma-separated list of directory names starting with
                         primary (default: primary,standby1,standby2,...)
  -l LOGFILE             write log messages to a file, but it will not log
                         any pre-check messages
  -L                     enable database logging in every instance
  -p PORTS               comma-separated list of ports to use starting with
                         primary (default: 5530,5531,5532,...)
  -r REPLICAS            number of replicas to create (default: 1)
  -s fan|tree|chain      replication structure (default: fan)
                         fan = all standbys connect directly to primary
                         tree = one standby connects directly to primary, the
                                remaining ones connect to that standby
                         chain = no more than one standby connects to any node
  -S                     configures all standbys to be synchronous
  -?                     show this help then exit
OPTIONSDOC
}

BLUE='\e[1;94m'
GREEN='\e[1;32m'
RED='\e[1;31m'

ENABLE_LOGS=false
SYNCHRONOUS=false

while getopts “a:d:l:Lp:r:s:S?” OPTION
do
  case $OPTION in
    a)
      ARCHIVE_DIR=$OPTARG
      ;;
    d)
      DIRS=$OPTARG
      ;;
    l)
      LOG_FILE=$OPTARG
      ;;
    L)
      ENABLE_LOGS=true
      ;;
    p)
      PORTS=$OPTARG
      ;;
    r)
      REPLICAS=$OPTARG
      ;;
    s)
      REPSTRUCT=$OPTARG
      ;;
    S)
      SYNCHRONOUS=true
      ;;
    ?)
      usage
      exit 1
      ;;
  esac
done

build_ascii_report()
{
  CURRENT_LEVEL=$INSTANCE

  # Indent everything according to replication structure.
  if [[ $CURRENT_LEVEL -eq 1 ]]
  then
    ASCII_REPORT="\n[Primary (${PORT_LIST[0]})]\n"
  else
    case $REPSTRUCT in
      fan)
        INDENT=1
        ;;
      tree)
        if [[ $CURRENT_STANDBY -eq 1 ]]
        then
          INDENT=1
        else
          INDENT=2
        fi
        ;;
      chain)
        INDENT=$CURRENT_STANDBY
        ;;
    esac

    SPACER=""
    for (( I=1; I <= $INDENT; I++ ))
    do
      SPACER=$SPACER"    "
      if [[ $I -gt 1 ]]
      then
        SPACER=$SPACER"    "
      fi
    done
    ASCII_REPORT=$ASCII_REPORT$SPACER"|\n"
    ASCII_REPORT=$ASCII_REPORT$SPACER"---[Standby $CURRENT_STANDBY (${PORT_LIST[$CURRENT_STANDBY]})]\n"

  fi
}

# Output text to a log file, prepending the date and time.
# Parameter 1 (optional): Contains 'STDOUT' if the entry should be displayed.
write_log()
{
  OUTPUT=$1
  NONEWLINE=$2

  if [[ $NONEWLINE == 'NONEWLINE' ]]
  then
    OPTION='-n'
  else
    OPTION=''
  fi

  while IFS= read -r LINE
  do
    if [[ $OUTPUT == STDOUT ]]
    then
        echo $OPTION $LINE
    fi

    echo "$(date +\%Y-\%m-\%d\ \%H:\%M:\%S) $LINE" >> $LOG_FILE
  done
}

# Writes a coloured title followed by its value
# Parameter 1: Title to be output in colour
# Parameter 2: Value
output_report()
{
  TITLE=$1
  VALUE=$2

  echo -ne "$BLUE  $TITLE: "
  tput sgr0
  echo $VALUE
}

# Based on the status provided, reports SUCCESS or FAILED
# Parameter 1: The exit code of the process being reported
report_status()
{
  STATUS=$1

  if [[ $STATUS -eq '0' ]] && [[ -n $STATUS ]]
  then
    echo -ne $GREEN # green
    echo -e " SUCCESS!" | write_log STDOUT
  else
    echo -ne $RED # red
    echo -e " FAILED!" | write_log STDOUT
  fi
  tput sgr0 # reset colours

  return $STATUS
}

IFS=","
PORT_LIST=($PORTS)
DIR_LIST=($DIRS)

# Check that we're using a supported version
if ( [[ PG_MAJOR_VERSION -eq 9 ]] && [[ PG_MINOR_VERSION -eq 0 ]] ) || [[ PG_MAJOR_VERSION -lt 9 ]]
then
  echo "Error: Only PostgreSQL 9.1 and above is supported.  You are using"\
       "PostgreSQL $PG_MAJOR_VERSION.$PG_MINOR_VERSION"
  exit 1
fi

# From PostgreSQL 9.2, the -X parameter on pg_basebackup is supported. Prior to
# that we have to use -x.
if ( [[ PG_MAJOR_VERSION -eq 9 ]] && [[ PG_MINOR_VERSION -ge 2 ]] ) || [[ PG_MAJOR_VERSION -gt 9 ]]
then
  BASEBACKUP_XLOG_OPTION='-Xstream'
else
  BASEBACKUP_XLOG_OPTION='-x'
fi

# From PostgreSQL 9.3, initdb accepts the -N parameter which tells it not to
# wait for files to be written to disk. We can do this as we're creating
# disposable databases anyway.
if ( [[ PG_MAJOR_VERSION -eq 9 ]] && [[ PG_MINOR_VERSION -ge 3 ]] ) || [[ PG_MAJOR_VERSION -gt 9 ]]
then
  INITDB_NOSYNC='-N'
fi

#### Validate parameters ####

# Set default number of replicas to 1.
if [[ -z $REPLICAS ]]
then
  REPLICAS=1
fi

# Check that the replicas value is numeric if provided.
if [[ -n $REPLICAS ]] && ! [[ $REPLICAS =~ ^[0-9]+$ ]]
then
  echo 'Error: The number of replicas must be a numeric value.'
  exit 1
fi

INSTANCES=`expr $REPLICAS + 1`

# Set default for log output
if [[ -z $LOG_FILE ]]
then
  LOG_FILE='/dev/null'
fi

# Validate replication structure value.
if [[ -n $REPSTRUCT ]]
then
  case $REPSTRUCT in
    fan|tree|chain)
      ;;
    * )
      echo 'Error: Invalid replica structure specified.'
      exit 1
  esac
else
  REPSTRUCT='fan'
fi

# Throw an error if any attempt to use a cascading replication feature prior to
# PostgreSQL 9.2.
if ( [[ PG_MAJOR_VERSION -eq 9 ]] && [[ PG_MINOR_VERSION -lt 2 ]] ) && [[ $REPSTRUCT != 'fan' ]]
then
  echo "Error: The replication structure '$REPSTRUCT' is not supported prior to"\
       "PostgreSQL 9.2 as it requires cascading replication."
  exit 1
fi

# Ensure that if a list of ports has been provided, the number of ports equals
# the number of replicas plus the primary.
if [[ -n $REPLICAS ]] && [[ -n $PORTS ]] && [[ ${#PORT_LIST[@]} -ne `expr $REPLICAS + 1` ]]
then
  echo 'Error: The number of ports provided does not match the number of replicas + primary.'
  exit 1
fi

# If a list of ports hasn't been specified, generate the list of ports.
if [[ -z $PORTS ]]
then
  PORT_LIST=()
  for (( PORT=5530, PORT_COUNT=0; PORT_COUNT <= $REPLICAS; PORT++ ))
  do
    if lsof -i:$PORT > /dev/null
    then
      continue; # port in use, so try next one
    else
      PORT_LIST+=($PORT)
      PORT_COUNT=$[PORT_COUNT + 1];
    fi
  done
else
  # Check that the ports listed aren't already in use.
  for PORT in ${PORT_LIST[@]}
  do
    if lsof -i:$PORT > /dev/null
    then
      echo "Error: Port $PORT already in use.  Specify a list of unused ports with the -p option."
      exit 1
    fi
  done
fi

# Check that the number of directories is equal to the number of standbys plus
# the primary.
if [[ -n $REPLICAS ]] && [[ -n $DIRS ]] && [[ ${#DIR_LIST[@]} -ne `expr $REPLICAS + 1` ]]
then
  echo 'Error: The number of directories provided does not match a primary + the number of replicas.'
  exit 1
fi

# If a list of directories was not explicitly specified, generate the default
# directory names.
if [[ -z $DIRS ]]
then
  DIR_LIST[0]='primary'
  for (( REPLICA=1; REPLICA <= $REPLICAS; REPLICA++ ))
  do
    DIR_LIST[$REPLICA]="standby$REPLICA"
  done
fi

# Check each directory to see if it's empty if it already exists.
for DIR in ${DIR_LIST[@]}
do
  if [[ -d $DIR ]]
  then
    if [[ $(ls -A $DIR) ]]
    then
      echo "Error: The directory '$DIR' already exists and is not empty."
      exit 1
    fi
  fi
done

#### Set up instances ####

IFS=" "
echo "Command issued: $0 $*" > $LOG_FILE
IFS=","

# Note that a 3rd value passed to output_report here has a coalescing effect
# where if the 2nd one is empty, the 3rd is accepted as the 2nd parameter.
echo "==== SETTINGS SUMMARY ===="
output_report "Replicas" $REPLICAS
output_report "Ports" "${PORT_LIST[*]}"
output_report "Directories" "${DIR_LIST[*]}"
output_report "Archive dir" $ARCHIVE_DIR "[None]"
output_report "Replication structure" $REPSTRUCT
output_report "Synchronous" $SYNCHRONOUS
output_report "Database logging" $ENABLE_LOGS
output_report "Log flie" $LOG_FILE
echo -e "==========================\n"

# Create directories.
for DIR in ${DIR_LIST[@]}
do
  if ! [[ -d $DIR ]]
  then
    mkdir -p -m 0700 $DIR &>> /dev/null

    if [[ $? -ne 0 ]]
    then
      echo "Error: Unable to create directory '$DIR'."
      exit 1
    fi
  else
    chmod 0700 $DIR
  fi
done

# Create archive directory
if [[ -n $ARCHIVE_DIR ]]
then
  mkdir -p -m 0700 $ARCHIVE_DIR

  # Check that the archive directory can be written to.  We can get away with
  # trying to create it first because if the directory already existed but
  # we don't have permissions to write to it, mkdir will act as if it succeeded.
  if ! [[ -w $ARCHIVE_DIR ]]
  then
    echo "Error: The archive directory '$ARCHIVE_DIR' doesn't have write permissions."
    exit 1
  fi
fi

# Initialise the primary and create standbys.

for (( INSTANCE=1; INSTANCE <= $INSTANCES; INSTANCE++ ))
do
  CURRENT_STANDBY=`expr $INSTANCE - 1`
  MAX_WAL_SENDERS=0
  DIR=${DIR_LIST[$CURRENT_STANDBY]}

  # Create the primary and create standby from base backup of primary.
  if [[ $INSTANCE -eq 1 ]]
  then
    echo -e "Creating primary in '$DIR'..." | write_log STDOUT NONEWLINE
    echo "initdb $INITDB_NOSYNC -D $DIR -E 'UTF8'" | write_log
    initdb $INITDB_NOSYNC -D $DIR -E 'UTF8' &>> $LOG_FILE
    report_status $?

    if [[ $? -ne 0 ]]
    then
      echo "Error: Unable to create primary."
      exit 1
    fi

    # Reduce the resource requirements to enable a large number of standbys.
    echo "shared_buffers = 8MB" >> $DIR/postgresql.conf

    if $ENABLE_LOGS
    then
      echo "logging_collector = on" >> $DIR/postgresql.conf
    fi

    # Define list of standbys.  We want to set this up in the primary prior to
    # base backup so that any promoted standby can use the same list.
    if $SYNCHRONOUS
    then
      SYNC_STANDBY_LIST='standby1'
      for (( SYNC_STANDBY=2; SYNC_STANDBY <= $REPLICAS; SYNC_STANDBY++ ))
      do
        SYNC_STANDBY_LIST=$SYNC_STANDBY_LIST",standby$SYNC_STANDBY"
      done
        echo "synchronous_standby_names = '$SYNC_STANDBY_LIST'" >> $DIR/postgresql.conf
    fi

    echo "archive_mode = on" >> $DIR/postgresql.conf
    if [[ -n $ARCHIVE_DIR ]]
    then
      echo -e "$(echo archive_command = \'cp \"%p\" \"`readlink -f $ARCHIVE_DIR`/%f\"\')" >> $DIR/postgresql.conf
    fi

    # Create a copy of the config before we modify it further because the
    # remaining settings should only apply to the primary. Every standby
    # will use this copy.
    cp $DIR/postgresql.conf{,.template}
  elif [[ $CURRENT_STANDBY -eq 1 ]]
  then
    echo -e "Creating standby $CURRENT_STANDBY from primary in '$DIR'..." | write_log STDOUT NONEWLINE
    echo "pg_basebackup -D $DIR -h 127.0.0.1 -p ${PORT_LIST[0]} $BASEBACKUP_XLOG_OPTION" | write_log
    pg_basebackup -D $DIR -h 127.0.0.1 -p ${PORT_LIST[0]} $BASEBACKUP_XLOG_OPTION &>> $LOG_FILE

    report_status $?

    if [[ $? -ne 0 ]]
    then
      continue
    fi

    # Remove unncessary files from standby
    rm "$DIR"/pg_xlog/*

    # Restore the original copy of the config for the standby as we want a
    # pristine copy, not the primary's modified one.
    mv $DIR/postgresql.conf{.template,}
    if [[ -n $ARCHIVE_DIR ]]
    then
      echo -e "$(echo restore_command = \'cp \"`readlink -f $ARCHIVE_DIR`/%f\" \"%p\"\')" >> $DIR/recovery.conf
    fi

    # Now that we've got one base backup, we can just copy it for every remaining standby.
    if [[ $REPLICAS -gt 1 ]]
    then
      for (( STANDBY=2; STANDBY<=$REPLICAS; STANDBY++ ))
      do
        echo -e "Creating copy of standby 1 for standby $STANDBY..." | write_log STDOUT NONEWLINE
        echo "cp -r $DIR/. ${DIR_LIST[$STANDBY]}" | write_log
        cp -r "$DIR/." "${DIR_LIST[$STANDBY]}"

        report_status $?

        if [[ $? -ne 0 ]]
        then
          continue
        fi
      done
    fi
  fi

  build_ascii_report

  # Set max_wal_senders appropriately so that it has a sufficient amount to
  # serve the standbys that will subscribe to it.
  case $REPSTRUCT in
    fan)
      # Only the primary will be sending WAL.
      if [[ $INSTANCE -eq 1 ]]
      then
        MAX_WAL_SENDERS=`expr $REPLICAS + 3`
      fi
      ;;
    tree)
      # Only the primary and 1st standby will be sending WAL.
      case $INSTANCE in
        1)
          MAX_WAL_SENDERS=3
          ;;
        2)
          MAX_WAL_SENDERS=`expr $REPLICAS + 2`
          ;;
      esac
      ;;
    chain)
      # The primary and every standby except the last will be sending WAL.
      if [[ $INSTANCE -lt `expr $REPLICAS + 1` ]]
      then
         MAX_WAL_SENDERS=3
      fi
      ;;
  esac

  # Configure to replicate.
  echo "wal_level = 'hot_standby'" >> $DIR/postgresql.conf
  echo "port = ${PORT_LIST[$CURRENT_STANDBY]}" >> $DIR/postgresql.conf

  # Only set up streaming replication configuration for instances that will
  # use it.
  if [[ $MAX_WAL_SENDERS > 0 ]]
  then
    echo "max_wal_senders = $MAX_WAL_SENDERS" >> $DIR/postgresql.conf
    echo "wal_keep_segments = 32" >> $DIR/postgresql.conf

    if [[ $INSTANCE -eq 1 ]]
    then
      # Add authentication entries to replicate to a slave.
      echo "local   replication     all                                trust" >> $DIR/pg_hba.conf
      echo "host    replication     all        127.0.0.1/32            trust" >> $DIR/pg_hba.conf
      echo "host    replication     all        ::1/128                 trust" >> $DIR/pg_hba.conf
    fi
  fi

  # Set all standbys to be hot standbys.
  if [[ $INSTANCE -ne 1 ]]
  then
    echo "hot_standby = on" >> $DIR/postgresql.conf
    echo "standby_mode = 'on'" >> $DIR/recovery.conf
    echo "recovery_target_timeline = 'latest'" >> $DIR/recovery.conf

    case $REPSTRUCT in
      fan)
        # All standbys subscribe to the primary directly.
        SUBSCRIBE_PORT=${PORT_LIST[0]}
        ;;
      tree)
        # Only the 1st standby subscribes directly to the primary. The rest
        # subscribe to the 1st standby.
        case $INSTANCE in
        2)
          SUBSCRIBE_PORT=${PORT_LIST[0]}
          ;;
        *)
          SUBSCRIBE_PORT=${PORT_LIST[1]}
          ;;
        esac
        ;;
      chain)
        # Every standby subscribes to the previous standby, or primary in the
        # case of the 1st standby.
        SUBSCRIBE_PORT=${PORT_LIST[`expr $INSTANCE - 2`]}
        ;;
    esac
    echo "primary_conninfo = 'host=127.0.0.1 port=$SUBSCRIBE_PORT application_name=standby$CURRENT_STANDBY'" >> $DIR/recovery.conf
  fi

  # Start the instance now that it's been configured.
  if [[ $INSTANCE -eq 1 ]]
  then
    echo "Starting primary..." | write_log STDOUT NONEWLINE
    echo "pg_ctl -D $DIR start" | write_log
    pg_ctl -D $DIR -s start >> $LOG_FILE
  else
    echo -e "Starting standby $CURRENT_STANDBY..." | write_log STDOUT NONEWLINE
    echo "pg_ctl -D $DIR start" | write_log
    pg_ctl -D $DIR -s start >> $LOG_FILE
  fi

  # Ensure everything is flushed to disk before checking whether the service
  # is up and running
  sync

  # Test that the primary or standby has started successfully.
  pg_ctl -D $DIR status >> $LOG_FILE
  report_status $?

  # If the primary fails, there's no point in continuing.
  if [[ $? -ne 0 ]] && [[ $INSTANCE -eq 1 ]]
  then
    echo "Error: Failed to start primary."
    exit 1;
  fi
done

# Output the final ASCII representation of the replication structure.
echo -e $ASCII_REPORT

exit 1
